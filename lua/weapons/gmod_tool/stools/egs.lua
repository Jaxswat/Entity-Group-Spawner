--[[--------------------------------------------------------------------------------------------------------------

    Copyright (C) 2024 by Jaxswat, All rights reserved.

    No parts of this code or any of its contents may be reproduced, copied, modified or adapted,
    without the prior written consent of the author, unless otherwise indicated for stand-alone materials.

]]----------------------------------------------------------------------------------------------------------------
--                                                           #((((((((((((((((((((((((((((
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--                                                           #(((((((((((((((((((((((((((#
--           ((((((((                                        #(((((((((((((((((((((((((((#
--          #((((((((#                                       #(((((((((((((((((((((((((((#
--         #((((((((((                                       #(((((((((((((((((((((((((((#
--         ((((((((((((                                      #(((((((((((((((((((((((((((#
--        #((((( *(((((#                                     #(((((((((((((((((((((((((((#
--       #(((((*  ((((((                                     #(((((((((((((((((((((((((((#
--       ((((((    ((((((                                    #(((((((((((((((((((((((((((#
--      ((((((     *(((((#                                   #(((((((((((((((((((((((((((#
--     #(((((/&&&&&&((((((#                                  #(((((((((((((((((((((((((((#
--    #((((((((((((((((((((                                  #(((((((((((((((((((((((((((#
--    (((((((((((((((((((((#                                 #(((((((((((((((((((((((((((#
--   #(((((           (((((((                                #(((((((((((((((((((((((((((#
--  #((((((            ((((((                                #(((((((((((((((((((((((((((#
--  ((((((             (((((((                               #((((((((((((((((((((((((((((
-- /(((((((((((((((((((((((((((((((((((((%        #((((((((((((((((((((((((((((((((((((((
-- /(((((((((((((((((((((((((( /((((((((((       ((((((((((( #(((((((((((((((((((((((((((
-- /((((((((((((((((((((((((((   ((((((((((%   %((((((((((*  #(((((((((((((((((((((((((((
-- /((((((((((((((((((((((((((    #(((((((((#  ((((((((((    ((((((((((((((((((((((((((((
-- /((((((((((((((((((((((((((/    *(((((((((#((((((((((     ((((((((((((((((((((((((((((
-- *((((((((((((((((((((((((((#      (((((((((((((((((       (((((((((((((((((((((((((((#
--  ((((((((((((((((((((((((((#       /(((((((((((((#        (((((((((((((((((((((((((((*
--  (((((((((((((((((((((((((((         ((((((((((((        ((((((((((((((((((((((((((((
--  ((((((((((((((((((((((((((((      %(((((((((((((%       ((((((((((((((((((((((((((((
--  ((((((((((((((((((((((((((((     (((((((((((((((((      (((((((((((((((((((((((((((/
--  ((((((((((((((((((((((((((((%  %(((((((((((((((((((#   ((((((((((((((((((((((((((((
--   ((((((((((((((((((((((((((((%#(((((((((#  (((((((((( #((((((((((((((((((((((((((((
--   ((((((((((((((((((((((((((((((((((((((*    ((((((((((((((((((((((((((((((((((((((*
--   *((((((((((((((((((((((((((((((((((((       (((((((((((((((((((((((((((((((((((((
--    (((((((((((((((((((((((((((((((((((#&&&&&&(((((((((((((((((((((((((((((((((((*
--    *((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--     #((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--      /((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((*
--       *(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--         (((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--          *((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--            *(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--               ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
--                 ,(((((((((((((((((((((((((((((((((((((((((((((((((((((((
--                     (((((((((((((((((((((((((((((((((((((((((((((((((
--                          *((((((((((((((((((((((((((((((((((((((
--                                  */(((((((((((((((((((((*

-- EGS Tool (Entity Group Spawner Tool)
-- Created by: Jaxswat
-- Email: contact@jaxswat.com
-- Website: jaxswat.com
-- Discord: jaxswat


TOOL.AddToMenu = true
TOOL.Category = "Jaxswat's Tools"
TOOL.Name = "#tool.egs.name"
TOOL.Description = "#tool.egs.desc"

--[[------------------------------------------
                EGS Convars
--]]------------------------------------------

---- Spawn Menu Compatability
------ Some folks were complaining about not seeing
------ the "spawn using EGS" in the spawn menu, so
------ This feature will let them use the "spawn using toolgun"
------ Keeping the convenience without making them uninstall anything.
TOOL.ClientConVar[ "spawnmenu_incompatible" ] = 0

---- Current Spawn Shape
TOOL.ClientConVar[ "ss" ] = 0
---- Current Spawn Relative Point
TOOL.ClientConVar[ "spawnrel" ] = 1
---- Current Spawn Rotation
TOOL.ClientConVar[ "spawnrot" ] = 0

-- Default entity settings.
TOOL.ClientConVar[ "ent_name" ] = "models/props_c17/oildrum001.mdl"
TOOL.ClientConVar[ "ent_weapon" ] = "none"
TOOL.ClientConVar[ "ent_type" ] = "4"
TOOL.ClientConVar[ "ent_gravity" ] = 1
TOOL.ClientConVar[ "ent_freeze" ] = 0

-- ALL Shape Variables
-- How much to offset entity positions in a shape.
TOOL.ClientConVar[ "ss_noise" ] = 0
-- How much to offset entity rotations in a shape.
TOOL.ClientConVar[ "ss_rotnoise" ] = 0
-- How much to offset entity elevations in a shape.
TOOL.ClientConVar[ "ss_height" ] = 0
-- How much to rotate the entity relative to the world. (ONLY WORKS WITH egs_spawnrot set to 6!)
TOOL.ClientConVar[ "ss_worldrot" ] = 0
-- How much to rotate the entity group relative to the world. (ONLY WORKS WITH egs_spawnrot set to 6!)
TOOL.ClientConVar[ "ss_worldgrouprot" ] = 0
-- When we shoot at a non-flat surface, should we rotate the EG to it?
TOOL.ClientConVar[ "ss_dorot" ] = 1
-- When we spawn the group, should it be rotated relative to the player?
TOOL.ClientConVar[ "ss_relative" ] = 1
-- When we spawn the group, should we add the model's AABB to the gap value upon spawning?
TOOL.ClientConVar[ "ss_usebb" ] = 1

-- Spawn Shape Square Convars
---- X and Y entity count.
TOOL.ClientConVar[ "ss_square_count_x" ] = 3
TOOL.ClientConVar[ "ss_square_count_y" ] = 3
---- X/Y gap between entities.
TOOL.ClientConVar[ "ss_square_gap" ] = 20
---- Edge only?
TOOL.ClientConVar[ "ss_square_edge" ] = 0
---- Checkered ?
TOOL.ClientConVar[ "ss_square_checkered" ] = 0
---- Invert Checkerboard pattern?
TOOL.ClientConVar[ "ss_square_checkered_invert" ] = 0

-- Spawn Shape Circle Convars
TOOL.ClientConVar[ "ss_circle_count" ] = 8
---- X/Y Radius of circle.
TOOL.ClientConVar[ "ss_circle_radius" ] = 100
---- Toggle edge or area of circle
TOOL.ClientConVar[ "ss_circle_edge" ] = 1

-- Shape List (Used for the Control Panel text and selection)
list.Set( "EGS_SpawnShapes", "Square Area (Default)", { egs_ss = 0 } )
list.Set( "EGS_SpawnShapes", "Circle Edge", { egs_ss = 1 } )

-- Spawn Offset list (Used for the Control Panel text and selection)
list.Set( "EGS_SpawnRelatives", "Centered", { egs_spawnrel = 0 } )
list.Set( "EGS_SpawnRelatives", "Front (Default)", { egs_spawnrel = 1 } )
list.Set( "EGS_SpawnRelatives", "Behind", { egs_spawnrel = 2 } )
list.Set( "EGS_SpawnRelatives", "Left", { egs_spawnrel = 3 } )
list.Set( "EGS_SpawnRelatives", "Right", { egs_spawnrel = 4 } )

-- Spawn Rotation list
list.Set( "EGS_SpawnRotations", "Facing shot (Default)", { egs_spawnrot = 0 } )
list.Set( "EGS_SpawnRotations", "Away from shot", { egs_spawnrot = 1 } )
list.Set( "EGS_SpawnRotations", "Facing shot position", { egs_spawnrot = 2 } )
list.Set( "EGS_SpawnRotations", "Away from shot position", { egs_spawnrot = 3 } )
list.Set( "EGS_SpawnRotations", "Facing Player", { egs_spawnrot = 4 } )
list.Set( "EGS_SpawnRotations", "Away from Player", { egs_spawnrot = 5 } )

-- EGS cleanup entry
cleanup.Register( "egs_entity_groups" )
-- Add EGS GUI icon
resource.AddFile("materials/icon16/egs.png")

if CLIENT then
    -- Language for the GUI
    language.Add("tool.egs.name", "Entity Group Spawner")
    language.Add("tool.egs.desc", "Spawn groups of entities in assorted shapes and formations!")
    language.Add("Undone.egs", "Undone Spawned Entity Group")
    language.Add("Undo.egs", "Spawned Entity Group")
    language.Add( "Cleanup_egs_entity_groups", "All Entity Groups [EGS]" )
    language.Add( "Cleaned_egs_entity_groups", "Cleaned up EGS Entity Groups" )
    language.Add("tool.egs.0", "Left Click to spawn a group of entities. Right Click to cause a small explosion in a random orphanage for the deaf. No, it's okay, they won't notice.")
end

function TOOL:GetCountColor( count )
  local color = LerpVector( count * 0.01, Vector(0, 1, 0), Vector(1, 0, 0) )
  color:Normalize()
  color = color:ToColor()
  return color
end

-- This thing is running a loop each toolgun draw. Needa cache that outsidhowbouthtgjdlfskjgjsd
function TOOL:GetEntityCount(spawnShape)
  if spawnShape == 0 then

    local total = 0
    local countX = self:GetClientNumber("ss_square_count_x")
    local countY = self:GetClientNumber("ss_square_count_y")
    local onlyEdge = self:GetClientNumber("ss_square_edge")
    local checkered = self:GetClientNumber("ss_square_checkered")
    local checkeredInvert = self:GetClientNumber("ss_square_checkered_invert")

    function doCheckeredSpawnCheck(x, y)
      if checkered == 1 then
        if checkeredInvert == 1 then
          if( (x + y) % 2 ~= 0) then
            total = total + 1
          end
        else
          if( (x + y) % 2 == 0) then
            total = total + 1
          end
        end
      else
        total = total + 1
      end
    end

    for x = 0, countX - 1 do
        for y = 0, countY - 1 do
            if onlyEdge == 1 then
                if ( x == 0 or x == countX - 1 or y == 0 or y == countY - 1) then
                  doCheckeredSpawnCheck(x, y)
                end
            else
              doCheckeredSpawnCheck(x, y)
            end
        end
    end
    return total
  elseif spawnShape == 1 then
    return self:GetClientNumber("ss_circle_count")
  end
end

function TOOL:DrawToolScreen( width, height )
	-- Draw black background
	surface.SetDrawColor( Color( 20, 20, 20 ) )
	surface.DrawRect( 0, 0, width, height )

  draw.SimpleText( "Entity Group Data", "DermaLarge", width / 2, 16, Color( 127, 168, 230 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_TOP )
  surface.SetDrawColor( Color( 127, 168, 230 ) )
	surface.DrawRect( 0, 55, 256, 4 )

  local spawnShape = self:GetClientNumber("ss")
  local type = self:GetClientNumber("ent_type")
  local count = self:GetEntityCount(spawnShape)

  if type == 0 then
    type = "Entity"
  elseif type == 1 then
    type = "Vehicle"
  elseif type == 2 then
    type = "NPC"
  elseif type == 3 then
    type = "Weapon"
  elseif type == 4 then
    type = "Prop/Ragdoll"
  end
  draw.SimpleText( "Type: " .. type, "DermaLarge", width / 2, height / 2, Color( 127, 168, 230 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )

  if spawnShape == 0 then
    draw.SimpleText( "Shape: Square", "DermaLarge", width / 2, height / 3, Color( 127, 168, 230 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    draw.SimpleText( "Total: " .. count, "DermaLarge", width / 2, height - (height / 3), self:GetCountColor(count), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
  elseif spawnShape == 1 then
    draw.SimpleText( "Shape: Circle", "DermaLarge", width / 2, height / 3, Color( 127, 168, 230 ), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
    draw.SimpleText( "Total: " .. count, "DermaLarge", width / 2, height - (height / 3), self:GetCountColor(count), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER )
  end
end

--[[
    The magical LEFT CLICK!
--]]
function TOOL:LeftClick( trace )

    -- Define a variable for the current spawn shape.
    local spawnShape = self:GetClientNumber("ss")

    -- Parse the retrieved value of the spawn shape.
    if spawnShape == 0 then
        return self:spawnSquare(trace)
    elseif spawnShape == 1 then
        return self:spawnCircle(trace)
    else
        -- The only way to get here is to manually put a non-existing shape number.
        -- Let's tell them about it in the console.
        print("Spawn Shape '" .. spawnShape .."' does not exist. Using default.")
        -- Also set it to the default value so we don't spam them in the future.
        self:GetOwner():ConCommand("egs_ss 0")
    end

    -- If we didn't already return a value above, show no shoot effects.
    return false
end

--[[
    The MASTER spawn entity function.
    Spawns any type of entity, and applies the custom settings.
--]]
function TOOL:spawnEntity(trace, localPos, spawnAngle, entName, entWep, entType, entGravity, entFreeze)

    -- Get the owner of the tool gun.
    local ply = self:GetOwner()
    -- Manipulate a new trace and not the one from the original click.
    local tr = self:copyObject(trace)
    -- Make the local position of the entity relative to the trace hit position.
    local spawnPos = localPos + tr.HitPos
    -- The below spawn functions take in a trace result. We have to set the
    -- Trace hit position to the actual entity position above.
    tr.HitPos = spawnPos

    -- Placeholder value for the returned entity.
    local ent = {}

    -- Parse the entity type and assign the result to the ent value above.

    -- SENT
    if ( entType == 0 ) then
        ent = self:EGS_Spawn_SENT(ply, entName, tr, spawnAngle)
    -- VEHICLE
    elseif ( entType == 1 ) then
        ent = self:EGS_Spawn_Vehicle(ply, entName, tr, spawnAngle)
    -- NPC
    elseif ( entType == 2 ) then
        ent = self:EGS_Spawn_NPC(ply, entName, entWep, tr, spawnAngle)
    -- WEAPON
    elseif ( entType == 3 ) then
        -- Don't return this entity. If it's undone later, it will be stripped from the players hands.
        -- Nobody wants that. Nobody.
        ent = self:EGS_Spawn_Weapon(ply, entName, tr, spawnAngle)
        return false
    -- PROP/RAGDOLL
    elseif ( entType == 4 ) then
        ent = self:EGS_Spawn_ERP(ply, nil, { entName }, tr, spawnAngle )
    end

    -- Is the above entity valid?
    if IsValid( ent ) then
        -- Get the physics body.
        local physBody = ent:GetPhysicsObject()

        -- Is the body valid?
        if physBody and physBody:IsValid() then
            -- Should we freeze it?
            if entFreeze == 1 then
                -- Freeze the physics body.
                physBody:EnableMotion( false )
            end
            -- Should we disable gravity?
            if entGravity == 0 then
                -- Disable gravity (Gravity is on by default!)
                physBody:EnableGravity( false )
            end


            -- If its a ragdoll, parse ALL the bones in the body and apply gravity and freeze settings.
            if ent:IsRagdoll() then
                -- Get the bone count.
                local bones = ent:GetPhysicsObjectCount()

                -- Parse all the bones and handle each of them.
                for b = 0, bones - 1 do

                    -- Should we freeze this bone?
                    if entFreeze == 1 then
                        -- Freeze the bone.
                        ent:GetPhysicsObjectNum(b):EnableMotion( false )
                    end
                    -- Should we disable gravity?
                    if entGravity == 0 then
                        -- Disable gravity for this bone.
                        ent:GetPhysicsObjectNum(b):EnableGravity( false )
                    end
                end
            end
        end

        -- Return the validated entity.
        return ent
    end

    -- The entity tripped and fell during spawning. Return false.
    return false
end

--[[
For compatability with other spawnmenu addons. See above: spawnmenu_incompatible
--]]
function TOOL:getLoadedEntity()
    return self:GetClientInfo("ent_name"), self:GetClientInfo("ent_weapon"), self:GetClientNumber("ent_type", 0)
end

--[[
    Spawn a square of entities using the given trace result and optional edge value.
--]]
function TOOL:spawnSquare(trace)
    -- Get convars (Read above where these are created to see what they do!)
    local onlyEdge = self:GetClientNumber("ss_square_edge")
    local checkered = self:GetClientNumber("ss_square_checkered")
    local checkeredInvert = self:GetClientNumber("ss_square_checkered_invert")
    local spawnRel = self:GetClientNumber("spawnrel")
    local spawnRot = self:GetClientNumber("spawnrot")
    local groupRel = self:GetClientNumber("ss_relative")
    local worldRot = self:GetClientNumber("ss_worldrot")
    local spawnHeight = self:GetClientNumber("ss_height")
    local usebb = self:GetClientNumber("ss_usebb")
    local worldGroupRot = self:GetClientNumber("ss_worldgrouprot")
    local doRot = self:GetClientNumber("ss_dorot")
    local spawnNoise = self:GetClientNumber("ss_noise")
    local spawnRotNoise = self:GetClientNumber("ss_rotnoise")
    local xCount = self:GetClientNumber("ss_square_count_x")
    local yCount = self:GetClientNumber("ss_square_count_y")
    local xGap = self:GetClientNumber("ss_square_gap")
    local yGap = xGap
    local entName, entWep, entType = self:getLoadedEntity()
    local entGravity = self:GetClientNumber("ent_gravity")
    local entFreeze = self:GetClientNumber("ent_freeze")
    local bbX = 0
    local bbY = 0
    -- The following functions are designed to be run on the serverside.
    -- To prevent lag on the client side, lets tell it to stop here.
    if CLIENT then return true end


    -- We need an entity to calculate AABB gaps.
    -- So we create and quickly remove one here, then do the group spawn with the resulting AABB + gap values.
    if usebb == 1 and entType ~= 3 then
        local spawnedEntity = self:spawnEntity(trace, Vector(0, 0, 0), Angle(0, 0 ,0), entName, entWep, entType, entGravity, entFreeze)

        if IsValid( spawnedEntity ) then
            if IsValid( spawnedEntity:GetPhysicsObject() ) then
                local min, max = spawnedEntity:GetPhysicsObject():GetAABB() or Vector(), Vector()
                local entPos = spawnedEntity:GetPos() or Vector()
                local offset = ((max - entPos) - (min - entPos))
                bbX = math.ceil(offset.x)
                bbY = math.ceil(offset.y)
            end
            spawnedEntity:Remove()
        end
    end

    if SERVER then
        -- Create a new Undo entry.
        undo.Create( "#Undo.egs" )
        -- Calculate the positions for the entities XY and spawn them with the correct settings.
        function doSquareSpawn(x, y)
            -- Generate a random number with the spawn noise value.
            local noiseX = math.random() + math.random(0, spawnNoise)
            local noiseY = math.random() + math.random(0, spawnNoise)
            local noiseRot = math.random() + math.random(0, spawnRotNoise)
            -- To get a random positive and negative value, lets get a number between 0 and 1.
            local addOrSubRot = math.random()
            local addOrSubX = math.random()
            local addOrSubY = math.random()
            -- The local position for this entity.
            local localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX) / 2), (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY) / 2), spawnHeight)
            -- The angle this entity should face.
            local spawnAngle = Angle(0, 0, 0)

            -- Don't apply a rotation if we aren't shooting a flat surface.
            -- Also filter spawning NPCs (which can't be rotated on walls and still work with node graph).
            local shouldEditAngle = true
            if (trace.HitNormal ~= Vector(0, 0, 1) and entType ~= 2) and doRot == 1 then
                local traceAng = trace.HitNormal:Angle()
                traceAng.x = traceAng.x + 90
                spawnAngle = traceAng
                shouldEditAngle = false

                -- What location relative to the shoot position should the group of entities spawn?
                -- (Left, right, center, front, back, etc.)
                -- These are inverted from the ones below due to the way the rotation spawns the entities.
                if spawnRel == 1 then
                    localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX)), (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY) / 2), 0)
                elseif spawnRel == 2 then
                    localPos = Vector( (x * (xGap + bbX)) + xCount, (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY) / 2), 0)
                elseif spawnRel == 3 then
                    localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX) / 2), (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY)), 0 )
                elseif spawnRel == 4 then
                    localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX) / 2), (y * (yGap + bbY)) + yCount, 0)
                end

                if addOrSubX > 0.5 then
                    localPos:Set( Vector(localPos.x + noiseX, localPos.y, localPos.z) )
                else
                    localPos:Set( Vector(localPos.x - noiseX, localPos.y, localPos.z) )
                end
                if addOrSubY > 0.5 then
                    localPos:Set( Vector(localPos.x, localPos.y + noiseY, localPos.z) )
                else
                    localPos:Set( Vector(localPos.x, localPos.y - noiseY, localPos.z) )
                end

                -- Rotate to fit the surface we shot.
                localPos:Rotate( traceAng )
            else
                -- What location relative to the shoot position should the group of entities spawn?
                -- (Left, right, center, front, back, etc.)
                if spawnRel == 1 then
                    localPos = Vector( (x * (xGap + bbX)) + xCount, (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY) / 2), 0)
                elseif spawnRel == 2 then
                    localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX)), (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY) / 2), 0)
                elseif spawnRel == 3 then
                    localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX) / 2), (y * (yGap + bbY)) + yCount, 0)
                elseif spawnRel == 4 then
                    localPos = Vector( (x * (xGap + bbX)) - ((xCount - 1) * (xGap + bbX) / 2), (y * (yGap + bbY)) - ((yCount - 1) * (yGap + bbY)), 0 )
                end


                if addOrSubX > 0.5 then
                    localPos:Set( Vector(localPos.x + noiseX, localPos.y, localPos.z) )
                else
                    localPos:Set( Vector(localPos.x - noiseX, localPos.y, localPos.z) )
                end
                if addOrSubY > 0.5 then
                    localPos:Set( Vector(localPos.x, localPos.y + noiseY, localPos.z) )
                else
                    localPos:Set( Vector(localPos.x, localPos.y - noiseY, localPos.z) )
                end

                if groupRel == 1 then
                    -- Rotate to fit the surface we shot.
                    localPos:Rotate( Angle(0, self:GetOwner():GetAngles().y, 0) )
                else
                    -- Rotate to the World Group Rotation variable.
                    localPos:Rotate( Angle(0, worldGroupRot, 0) )
                end
            end

            -- Create an entity with ALL the settings above applied.
            local spawnedEntity = self:spawnEntity(trace, localPos, spawnAngle, entName, entWep, entType, entGravity, entFreeze)

            -- Is the entity valid?
            if IsValid( spawnedEntity ) then
                -- Should we modify the angle? (Are we on a flat surface?)
                if shouldEditAngle then
                    -- Variable to store our new angle.
                    local angle = (spawnAngle + spawnedEntity:GetAngles())

                    -- Which way should we face the entity? Reference the list of "EGS_SpawnRotations" above.
                    if spawnRot == 0 then
                        angle = Angle(angle.x, self:GetOwner():EyeAngles().y - 180, angle.z)
                        spawnedEntity:SetAngles( angle )
                    elseif spawnRot == 1 then
                        angle = Angle(angle.x, self:GetOwner():EyeAngles().y, angle.z)
                        spawnedEntity:SetAngles( angle )
                    elseif spawnRot == 2 then
                        spawnedEntity:SetAngles( ( trace.HitPos - spawnedEntity:GetPos() ):Angle() )
                        spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                        angle = (angle + spawnedEntity:GetAngles())
                        spawnedEntity:SetAngles( angle )
                    elseif spawnRot == 3 then
                        -- Up vector relative to world
                        local upVector = Vector(0, 0, 1)
                        -- Angle pointing to the player
                        local toPlayerAngle = ( trace.HitPos - spawnedEntity:GetPos() ):Angle()
                        -- Rotates the vector to be relative to the player.
                        upVector:Rotate( toPlayerAngle )
                        -- Turns the toPlayerAngle away from the player.
                        toPlayerAngle:RotateAroundAxis(upVector, 180)
                        spawnedEntity:SetAngles( toPlayerAngle )
                        spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                        angle = (angle + spawnedEntity:GetAngles())
                        spawnedEntity:SetAngles( angle )
                    elseif spawnRot == 4 then
                        -- Same as the top statement for spawnRot 3, just easier to write.
                        spawnedEntity:PointAtEntity(self:GetOwner())
                        spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                        angle = (angle + spawnedEntity:GetAngles())
                        spawnedEntity:SetAngles( angle )
                    elseif spawnRot == 5 then
                        -- Up vector relative to world
                        local upVector = Vector(0, 0, 1)
                        -- Angle pointing to the player
                        local toPlayerAngle = ( self:GetOwner():GetPos() - spawnedEntity:GetPos() ):Angle()
                        -- Rotates the vector to be relative to the player.
                        upVector:Rotate( toPlayerAngle )
                        -- Turns the toPlayerAngle away from the player.
                        toPlayerAngle:RotateAroundAxis(upVector, 180)
                        spawnedEntity:SetAngles( toPlayerAngle )
                        spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                        angle = (angle + spawnedEntity:GetAngles())
                        spawnedEntity:SetAngles( angle )
                    end

                    -- Now that we have the spawn rotation, let's add the noise to it.
                    if addOrSubRot > 0.5 then
                        spawnedEntity:SetAngles( Angle( spawnedEntity:GetAngles().x, spawnedEntity:GetAngles().y + noiseRot, spawnedEntity:GetAngles().z ) )
                    else
                        spawnedEntity:SetAngles( Angle( spawnedEntity:GetAngles().x, spawnedEntity:GetAngles().y - noiseRot, spawnedEntity:GetAngles().z ) )
                    end
                end

                -- Add it to the current undo, and to ALL EGS groups (for a "clean up everything")
                undo.AddEntity( spawnedEntity )
                self:GetOwner():AddCleanup( "egs_entity_groups", spawnedEntity )
            end
        end

        function doCheckeredSpawnCheck(x, y)
          if checkered == 1 then
            if checkeredInvert == 1 then
              if( (x + y) % 2 ~= 0) then
                doSquareSpawn(x, y)
              end
            else
              if( (x + y) % 2 == 0) then
                doSquareSpawn(x, y)
              end
            end
          else
            doSquareSpawn(x, y)
          end
        end

        for x = 0, xCount - 1 do
            for y = 0, yCount - 1 do
                if onlyEdge == 1 then
                    if ( x == 0 or x == xCount - 1 or y == 0 or y == yCount - 1) then
                      doCheckeredSpawnCheck(x, y)
                    end
                else
                  doCheckeredSpawnCheck(x, y)
                end
            end
        end

        -- Set the undo owner to the tool gun owner.
        undo.SetPlayer( self:GetOwner() )
        -- Set the undo text to the custom language table above.
        undo.SetCustomUndoText("#Undone.egs")
        -- End the undo contents and add it to the list.
        undo.Finish("#Undo.egs")
        -- All went well. Lets return true.
        return true
    end
end

--[[
    Spawn a circle of entities using the given trace result.
--]]

function TOOL:spawnCircle(trace)

    -- Get convars (Read above where these are created to see what they do!)
    local spawnRel = self:GetClientNumber("spawnrel")
    local spawnRot = self:GetClientNumber("spawnrot")
    local groupRel = self:GetClientNumber("ss_relative")
    local worldRot = self:GetClientNumber("ss_worldrot")
    local spawnHeight = self:GetClientNumber("ss_height")
    local usebb = self:GetClientNumber("ss_usebb")
    local worldGroupRot = self:GetClientNumber("ss_worldgrouprot")
    local doRot = self:GetClientNumber("ss_dorot")
    local spawnNoise = self:GetClientNumber("ss_noise")
    local spawnRotNoise = self:GetClientNumber("ss_rotnoise")
    local xRadius = self:GetClientNumber("ss_circle_radius")
    local yRadius = xRadius
    local count = self:GetClientNumber("ss_circle_count")
    local entName, entWep, entType = self:getLoadedEntity()
    local entGravity = self:GetClientNumber("ent_gravity")
    local entFreeze = self:GetClientNumber("ent_freeze")
    local bbX = 0
    local bbY = 0
    -- The following functions are designed to be run on the serverside.
    -- To prevent lag on the client side, lets tell it to stop here.
    if CLIENT then return true end

    -- We need an entity to calculate AABB gaps.
    -- So we create and quickly remove one here, then do the group spawn with the resulting AABB + gap values.
    if usebb == 1 and entType ~= 3 then
        local spawnedEntity = self:spawnEntity(trace, Vector(0, 0, 0), Angle(0, 0 ,0), entName, entWep, entType, entGravity, entFreeze)

        if IsValid( spawnedEntity ) then
            if IsValid( spawnedEntity:GetPhysicsObject() ) then
              local min, max = spawnedEntity:GetPhysicsObject():GetAABB() or Vector(), Vector()
              local entPos = spawnedEntity:GetPos() or Vector()
                local offset = ((max - entPos) - (min - entPos))
                bbX = math.ceil(offset.x * (count / 4))
                bbY = math.ceil(offset.y * (count / 4))
            end
            spawnedEntity:Remove()
        end
    end

    if SERVER then
      function doCircleSpawn(a)
          -- Generate a random number with the spawn noise value.
          local noiseX = math.random() + math.random(0, spawnNoise)
          local noiseY = math.random() + math.random(0, spawnNoise)
          local noiseRot = math.random() + math.random(0, spawnRotNoise)
          -- To get a random positive and negative value, lets get a number between 0 and 1.
          local addOrSubRot = math.random()
          local addOrSubX = math.random()
          local addOrSubY = math.random()
          local theta = (math.pi * 2) / count;
          local angle = (theta * a);
          -- The local position for this entity.
          local localPos = Vector((xRadius + bbY) * math.cos(angle), (yRadius + bbY) * math.sin(angle), spawnHeight)
          -- The angle this entity should face.
          local spawnAngle = Angle(0, 0, 0)

          -- Don't apply a rotation if we aren't shooting a flat surface.
          -- Also filter spawning NPCs (which can't be rotated on walls and still work with node graph).
          local shouldEditAngle = true
          if (trace.HitNormal ~= Vector(0, 0, 1) and entType ~= 2) and doRot == 1 then
              local traceAng = trace.HitNormal:Angle()
              traceAng.x = traceAng.x + 90
              spawnAngle = traceAng
              shouldEditAngle = false

              -- What location relative to the shoot position should the group of entities spawn?
              -- (Left, right, center, front, back, etc.)
              -- These are inverted from the ones below due to the way the rotation spawns the entities.
              if spawnRel == 1 then
                  localPos = Vector(((xRadius + bbY) * math.cos(angle)) - (xRadius + bbY), (yRadius + bbY) * math.sin(angle), 0)
              elseif spawnRel == 2 then
                  localPos = Vector(((xRadius + bbY) * math.cos(angle)) + (xRadius + bbY), (yRadius + bbY) * math.sin(angle), 0)
              elseif spawnRel == 3 then
                  localPos = Vector( (xRadius + bbY) * math.sin(angle), ((yRadius + bbY) * math.cos(angle)) - (yRadius + bbY), 0)
              elseif spawnRel == 4 then
                  localPos = Vector( (xRadius + bbY) * math.sin(angle), ((yRadius + bbY) * math.cos(angle)) + (yRadius + bbY), 0)
              end

              if addOrSubX > 0.5 then
                  localPos:Set( Vector(localPos.x + noiseX, localPos.y, localPos.z) )
              else
                  localPos:Set( Vector(localPos.x - noiseX, localPos.y, localPos.z) )
              end
              if addOrSubY > 0.5 then
                  localPos:Set( Vector(localPos.x, localPos.y + noiseY, localPos.z) )
              else
                  localPos:Set( Vector(localPos.x, localPos.y - noiseY, localPos.z) )
              end

              -- Rotate to fit the surface we shot.
              localPos:Rotate( traceAng )
          else
              -- What location relative to the shoot position should the group of entities spawn?
              -- (Left, right, center, front, back, etc.)
              if spawnRel == 1 then
                  localPos = Vector(((xRadius + bbY) * math.cos(angle)) + (xRadius + bbY), (yRadius + bbY) * math.sin(angle), 0)
              elseif spawnRel == 2 then
                  localPos = Vector(((xRadius + bbY) * math.cos(angle)) - (xRadius + bbY), (yRadius + bbY) * math.sin(angle), 0)
              elseif spawnRel == 3 then
                 localPos = Vector( (xRadius + bbY) * math.sin(angle), ((yRadius + bbY) * math.cos(angle)) + (yRadius + bbY), 0)
              elseif spawnRel == 4 then
                  localPos = Vector( (xRadius + bbY) * math.sin(angle), ((yRadius + bbY) * math.cos(angle)) - (yRadius + bbY), 0)
              end


              if addOrSubX > 0.5 then
                  localPos:Set( Vector(localPos.x + noiseX, localPos.y, localPos.z) )
              else
                  localPos:Set( Vector(localPos.x - noiseX, localPos.y, localPos.z) )
              end
              if addOrSubY > 0.5 then
                  localPos:Set( Vector(localPos.x, localPos.y + noiseY, localPos.z) )
              else
                  localPos:Set( Vector(localPos.x, localPos.y - noiseY, localPos.z) )
              end

              if groupRel == 1 then
                  -- Rotate to fit the surface we shot.
                  localPos:Rotate( Angle(0, self:GetOwner():GetAngles().y, 0) )
              else
                  -- Rotate to the World Group Rotation variable.
                  localPos:Rotate( Angle(0, worldGroupRot, 0) )
              end
          end

          -- Create an entity with ALL the settings above applied.
          local spawnedEntity = self:spawnEntity(trace, localPos, spawnAngle, entName, entWep, entType, entGravity, entFreeze)

          -- Is the entity valid?
          if IsValid( spawnedEntity ) then
              -- Should we modify the angle? (Are we on a flat surface?)
              if shouldEditAngle then
                  -- Variable to store our new angle.
                  local angle = (spawnAngle + spawnedEntity:GetAngles())

                  -- Which way should we face the entity? Reference the list of "EGS_SpawnRotations" above.
                  if spawnRot == 0 then
                      angle = Angle(angle.x, self:GetOwner():EyeAngles().y - 180, angle.z)
                      spawnedEntity:SetAngles( angle )
                  elseif spawnRot == 1 then
                      angle = Angle(angle.x, self:GetOwner():EyeAngles().y, angle.z)
                      spawnedEntity:SetAngles( angle )
                  elseif spawnRot == 2 then
                      spawnedEntity:SetAngles( ( trace.HitPos - spawnedEntity:GetPos() ):Angle() )
                      spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                      angle = (angle + spawnedEntity:GetAngles())
                      spawnedEntity:SetAngles( angle )
                  elseif spawnRot == 3 then
                      -- Up vector relative to world
                      local upVector = Vector(0, 0, 1)
                      -- Angle pointing to the player
                      local toPlayerAngle = ( trace.HitPos - spawnedEntity:GetPos() ):Angle()
                      -- Rotates the vector to be relative to the player.
                      upVector:Rotate( toPlayerAngle )
                      -- Turns the toPlayerAngle away from the player.
                      toPlayerAngle:RotateAroundAxis(upVector, 180)
                      spawnedEntity:SetAngles( toPlayerAngle )
                      spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                      angle = (angle + spawnedEntity:GetAngles())
                      spawnedEntity:SetAngles( angle )
                  elseif spawnRot == 4 then
                      -- Same as the top statement for spawnRot 3, just easier to write.
                      spawnedEntity:PointAtEntity(self:GetOwner())
                      spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                      angle = (angle + spawnedEntity:GetAngles())
                      spawnedEntity:SetAngles( angle )
                  elseif spawnRot == 5 then
                      -- Up vector relative to world
                      local upVector = Vector(0, 0, 1)
                      -- Angle pointing to the player
                      local toPlayerAngle = ( self:GetOwner():GetPos() - spawnedEntity:GetPos() ):Angle()
                      -- Rotates the vector to be relative to the player.
                      upVector:Rotate( toPlayerAngle )
                      -- Turns the toPlayerAngle away from the player.
                      toPlayerAngle:RotateAroundAxis(upVector, 180)
                      spawnedEntity:SetAngles( toPlayerAngle )
                      spawnedEntity:SetAngles( Angle( 0, spawnedEntity:GetAngles().y, 0 ) )
                      angle = (angle + spawnedEntity:GetAngles())
                      spawnedEntity:SetAngles( angle )
                  end

                  -- Now that we have the spawn rotation, let's add the noise to it.
                  if addOrSubRot > 0.5 then
                      spawnedEntity:SetAngles( Angle( spawnedEntity:GetAngles().x, spawnedEntity:GetAngles().y + noiseRot, spawnedEntity:GetAngles().z ) )
                  else
                      spawnedEntity:SetAngles( Angle( spawnedEntity:GetAngles().x, spawnedEntity:GetAngles().y - noiseRot, spawnedEntity:GetAngles().z ) )
                  end
              end

              -- Add it to the current undo, and to ALL EGS groups (for a "clean up everything")
              undo.AddEntity( spawnedEntity )
              self:GetOwner():AddCleanup( "egs_entity_groups", spawnedEntity )
              return true
          end
      end
        undo.Create( "#Undone_egs" )

        for a = 1, count do
            doCircleSpawn(a)
        end

        -- Set the undo owner to the tool gun owner.
        undo.SetPlayer( self:GetOwner() )
        -- Set the undo text to the custom language table above.
        undo.SetCustomUndoText("#Undone.egs")
        -- End the undo contents and add it to the list.
        undo.Finish("#Undo.egs")

        -- All went well. Lets return true.
        return true
    end
end

local ConVarsDefault = TOOL:BuildConVarList()

function TOOL.BuildCPanel( rootPanel )

    local squareSettings = vgui.Create( "DForm")
    squareSettings:SetName( "Square Shape Settings" )

    local square_xCountSlider = vgui.Create( "DNumSlider")
    square_xCountSlider:SetText( "Entity Count X" )
    square_xCountSlider:SetDark( 1 )
    square_xCountSlider:SetMin( 1 )
    square_xCountSlider:SetMax( 10 )
    square_xCountSlider:SetDecimals( 0 )
    square_xCountSlider:SetConVar( "egs_ss_square_count_x" )

    local square_yCountSlider = vgui.Create( "DNumSlider")
    square_yCountSlider:SetText( "Entity Count Y" )
    square_yCountSlider:SetDark( 1 )
    square_yCountSlider:SetMin( 1 )
    square_yCountSlider:SetMax( 10 )
    square_yCountSlider:SetDecimals( 0 )
    square_yCountSlider:SetConVar( "egs_ss_square_count_y" )

    local square_gapSlider = vgui.Create( "DNumSlider" )
    square_gapSlider:SetText( "Entity Gap" )
    square_gapSlider:SetDark( 1 )
    square_gapSlider:SetMin( 0 )
    square_gapSlider:SetMax( 200 )
    square_gapSlider:SetDecimals( 0 )
    square_gapSlider:SetConVar( "egs_ss_square_gap" )

    local edgeCheckbox = vgui.Create( "DCheckBoxLabel" )
    edgeCheckbox:SetDark( 1 )
    edgeCheckbox:SetText( "Edge Only" )
    edgeCheckbox:SetConVar( "egs_ss_square_edge" )
    local checkeredCheckbox = vgui.Create( "DCheckBoxLabel" )
    checkeredCheckbox:SetDark( 1 )
    checkeredCheckbox:SetText( "Checkered" )
    checkeredCheckbox:SetConVar( "egs_ss_square_checkered" )
    local checkeredInvertCheckbox = vgui.Create( "DCheckBoxLabel" )
    checkeredInvertCheckbox:SetDark( 1 )
    checkeredInvertCheckbox:SetText( "Invert Checkered Pattern" )
    checkeredInvertCheckbox:SetConVar( "egs_ss_square_checkered_invert" )

    squareSettings:AddItem(edgeCheckbox)
    squareSettings:AddItem(checkeredCheckbox)
    squareSettings:AddItem(checkeredInvertCheckbox)
    squareSettings:AddItem(square_xCountSlider)
    squareSettings:AddItem(square_yCountSlider)
    squareSettings:AddItem(square_gapSlider)

    local circleSettings = vgui.Create( "DForm")
    circleSettings:SetName( "Circle Shape Settings" )

    local circle_countSlider = vgui.Create( "DNumSlider")
    circle_countSlider:SetText( "Circle Entity Count" )
    circle_countSlider:SetDark( 1 )
    circle_countSlider:SetMin( 1 )
    circle_countSlider:SetMax( 100 )
    circle_countSlider:SetDecimals( 0 )
    circle_countSlider:SetConVar( "egs_ss_circle_count" )

    local circle_radiusSlider = vgui.Create( "DNumSlider")
    circle_radiusSlider:SetText( "Radius" )
    circle_radiusSlider:SetDark( 1 )
    circle_radiusSlider:SetMin( 0 )
    circle_radiusSlider:SetMax( 500 )
    circle_radiusSlider:SetDecimals( 0 )
    circle_radiusSlider:SetConVar( "egs_ss_circle_radius" )

    circleSettings:AddItem(circle_countSlider)
    circleSettings:AddItem(circle_radiusSlider)

    rootPanel:Help( "To load an entity, go to the Spawn Menu > right click a tile > select the EGS option. It's like magic." )
    -- rootPanel:Help( "" )

    rootPanel:Help( "Presets:" )
    rootPanel:AddControl( "ComboBox", { MenuButton = 1, Folder = "egs", Options = { [ "#preset.default" ] = ConVarsDefault }, CVars = table.GetKeys( ConVarsDefault ) } )
    rootPanel:AddControl( "ComboBox", { Label = "Current Shape", Options = list.Get( "EGS_SpawnShapes" ) } )
    rootPanel:AddControl( "ComboBox", { Label = "Spawn relative to...", Options = list.Get( "EGS_SpawnRelatives" ) } )
    rootPanel:AddControl( "ComboBox", { Label = "Face entity...", Options = list.Get( "EGS_SpawnRotations" ) } )
    rootPanel:AddControl( "CheckBox", { Label = "Gravity", Command = "egs_ent_gravity" } )
    rootPanel:AddControl( "CheckBox", { Label = "Freeze", Command = "egs_ent_freeze" } )

    -- aint nobody gon' use this feature. It's just gonna clutter everything
    -- and make it look overwhleming.

    -- local randomPosSlider = vgui.Create( "DNumSlider")
    -- randomPosSlider:SetText( "Position Randomness" )
    -- randomPosSlider:SetDark( 1 )
    -- randomPosSlider:SetMin( 0 )
    -- randomPosSlider:SetMax( 10 )
    -- randomPosSlider:SetDecimals( 0 )
    -- randomPosSlider:SetConVar( "egs_ss_noise" )

    local randomRotSlider = vgui.Create( "DNumSlider")
    randomRotSlider:SetText( "Random Rotation" )
    randomRotSlider:SetDark( 1 )
    randomRotSlider:SetMin( 0 )
    randomRotSlider:SetMax( 180 )
    randomRotSlider:SetDecimals( 0 )
    randomRotSlider:SetConVar( "egs_ss_rotnoise" )

    -- rootPanel:AddItem(randomPosSlider)
    rootPanel:AddItem(randomRotSlider)

    rootPanel:AddItem(squareSettings)
    rootPanel:AddItem(circleSettings)

end

function TOOL:copyObject(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[self:copyObject(orig_key)] = self:copyObject(orig_value)
        end
        setmetatable(copy, self:copyObject(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

-------------------------------------------
-------------------------------------------
 --      SPAWN ENTITY OVERRIDES
-------------------------------------------
-------------------------------------------

function TOOL:EGS_Spawn_Weapon( Player, wepname, tr, Angles )

    if ( wepname == nil ) then return end

    local swep = list.Get( "Weapon" )[ wepname ]

    if ( swep == nil ) then return end

    if ( ( !swep.Spawnable && !Player:IsAdmin() ) || ( swep.AdminOnly && !Player:IsAdmin() ) ) then
        return
    end

    if ( !gamemode.Call( "PlayerSpawnSWEP", Player, wepname, swep ) ) then return end

    if ( !tr ) then
        tr = Player:GetEyeTraceNoCursor()
    end

    if ( !tr.Hit ) then return end

    local entity = ents.Create( swep.ClassName )

    if ( IsValid( entity ) ) then

        entity:SetPos( tr.HitPos + tr.HitNormal * 32 )
        entity:Spawn()
        entity:SetAngles(Angles)

        gamemode.Call( "PlayerSpawnedSWEP", Player, entity )
        return entity
    end
end

local function EGSInternalSpawnNPC( Player, Angles, Position, Normal, Class, Equipment, SpawnFlagsSaved, NoDropToFloor )

    local NPCList = list.Get( "NPC" )
    local NPCData = NPCList[ Class ]

    if ( NPCData.AdminOnly && !Player:IsAdmin() ) then return end

    local bDropToFloor = false

    if ( NPCData.OnCeiling && Vector( 0, 0, -1 ):Dot( Normal ) < 0.95 ) then
        return nil
    end

    if ( NPCData.OnFloor && Vector( 0, 0, 1 ):Dot( Normal ) < 0.95 ) then
        return nil
    else
        bDropToFloor = true
    end

    if ( NPCData.NoDrop || NoDropToFloor ) then bDropToFloor = false end

    local NPC = ents.Create( NPCData.Class )
    if ( !IsValid( NPC ) ) then return end

    local Offset = NPCData.Offset or 32
    Position = Position + Normal * Offset
    NPC:SetPos( Position )

    if ( NPCData.Rotate ) then Angles = Angles + NPCData.Rotate end

    NPC:SetAngles( Angles )

    if ( NPCData.Model ) then
        NPC:SetModel( NPCData.Model )
    end

    if ( NPCData.Material ) then
        NPC:SetMaterial( NPCData.Material )
    end

    local SpawnFlags = bit.bor( SF_NPC_FADE_CORPSE, SF_NPC_ALWAYSTHINK )
    if ( NPCData.SpawnFlags ) then SpawnFlags = bit.bor( SpawnFlags, NPCData.SpawnFlags ) end
    if ( NPCData.TotalSpawnFlags ) then SpawnFlags = NPCData.TotalSpawnFlags end
    if ( SpawnFlagsSaved ) then SpawnFlags = SpawnFlagsSaved end
    NPC:SetKeyValue( "spawnflags", SpawnFlags )
    NPC.SpawnFlags = SpawnFlags

    if ( NPCData.KeyValues ) then
        for k, v in pairs( NPCData.KeyValues ) do
            NPC:SetKeyValue( k, v )
        end
    end

    if ( NPCData.Skin ) then
        NPC:SetSkin( NPCData.Skin )
    end

    local valid = false
    for _, v in pairs( list.Get( "NPCUsableWeapons" ) ) do
        if v.class == Equipment then valid = true break end
    end

    if ( Equipment && Equipment != "none" && valid ) then
        NPC:SetKeyValue( "additionalequipment", Equipment )
        NPC.Equipment = Equipment
    end

    DoPropSpawnedEffect( NPC )

    NPC:Spawn()
    NPC:Activate()

    if ( bDropToFloor && !NPCData.OnCeiling ) then
        NPC:DropToFloor()
    end

    return NPC

end

function TOOL:EGS_Spawn_NPC( player, NPCClassName, WeaponName, tr, angle )

    if ( !NPCClassName ) then return end

    if ( !gamemode.Call( "PlayerSpawnNPC", player, NPCClassName, WeaponName ) ) then return end

    if ( !tr ) then

        local vStart = player:GetShootPos()
        local vForward = player:GetAimVector()

        local trace = {}
        trace.start = vStart
        trace.endpos = vStart + vForward * 2048
        trace.filter = player

        tr = util.TraceLine( trace )

    end

    local SpawnedNPC = EGSInternalSpawnNPC( player, angle, tr.HitPos, tr.HitNormal, NPCClassName, WeaponName )
    if ( !IsValid( SpawnedNPC ) ) then return end

    if ( IsValid( player ) ) then
        gamemode.Call( "PlayerSpawnedNPC", player, SpawnedNPC )
    end

    local NPCList = list.Get( "NPC" )
    local NiceName = nil
    if ( NPCList[ NPCClassName ] ) then
        NiceName = NPCList[ NPCClassName ].Name
    end

    player:AddCleanup( "npcs", SpawnedNPC )
    player:SendLua( "achievements.SpawnedNPC()" )

    return SpawnedNPC

end

local function EGSMakeVehicle( Player, Pos, Ang, Model, Class, VName, VTable, data )

    if ( !gamemode.Call( "PlayerSpawnVehicle", Player, Model, VName, VTable ) ) then return end

    local Ent = ents.Create( Class )
    if ( !Ent ) then return NULL end

    duplicator.DoGeneric( Ent, data )

    Ent:SetModel( Model )

    if ( Model == "models/buggy.mdl" ) then Ent:SetKeyValue( "vehiclescript", "scripts/vehicles/jeep_test.txt" ) end
    if ( Model == "models/vehicle.mdl" ) then Ent:SetKeyValue( "vehiclescript", "scripts/vehicles/jalopy.txt" ) end

    if ( VTable && VTable.KeyValues ) then
        for k, v in pairs( VTable.KeyValues ) do

            local kLower = string.lower( k )

            if ( kLower == "vehiclescript" ||
                 kLower == "limitview"     ||
                 kLower == "vehiclelocked" ||
                 kLower == "cargovisible"  ||
                 kLower == "enablegun" )
            then
                Ent:SetKeyValue( k, v )
            end
        end
    end

    Ent:SetAngles( Ang )
    Ent:SetPos( Pos )

    DoPropSpawnedEffect( Ent )

    Ent:Spawn()
    Ent:Activate()

    if ( Ent.SetVehicleClass && VName ) then Ent:SetVehicleClass( VName ) end
    Ent.VehicleName = VName
    Ent.VehicleTable = VTable
    Ent.ClassOverride = Class

    if ( IsValid( Player ) ) then
        gamemode.Call( "PlayerSpawnedVehicle", Player, Ent )
    end

    return Ent

end

function TOOL:EGS_Spawn_Vehicle( Player, vname, tr, Angles )

    if ( !vname ) then return end

    local VehicleList = list.Get( "Vehicles" )
    local vehicle = VehicleList[ vname ]

    if ( !vehicle ) then return end

    if ( !tr ) then
        tr = Player:GetEyeTraceNoCursor()
    end

    local pos = tr.HitPos
    if ( vehicle.Offset ) then
        pos = pos + tr.HitNormal * vehicle.Offset
    end

    local Ent = EGSMakeVehicle( Player, pos, Angles, vehicle.Model, vehicle.Class, vname, vehicle )
    if ( !IsValid( Ent ) ) then return end

    if ( vehicle.Members ) then
        table.Merge( Ent, vehicle.Members )
        duplicator.StoreEntityModifier( Ent, "VehicleMemDupe", vehicle.Members )
    end
    Player:AddCleanup( "vehicles", Ent )
    return Ent

end

local function EGSCanPlayerSpawnSENT( player, EntityName )

    local sent = scripted_ents.GetStored( EntityName )
    if ( sent == nil ) then

        local SpawnableEntities = list.Get( "SpawnableEntities" )
        if ( !SpawnableEntities ) then return false end
        local EntTable = SpawnableEntities[ EntityName ]
        if ( !EntTable ) then return false end
        if ( EntTable.AdminOnly && !player:IsAdmin() ) then return false end
        return true

    end

    local SpawnFunction = scripted_ents.GetMember( EntityName, "SpawnFunction" )
    if ( !isfunction( SpawnFunction ) ) then return false end

    if ( !scripted_ents.GetMember( EntityName, "Spawnable" ) && !player:IsAdmin() ) then return false end
    if ( scripted_ents.GetMember( EntityName, "AdminOnly" ) && !player:IsAdmin() ) then return false end

    return true

end

function TOOL:EGS_Spawn_SENT( player, EntityName, tr, Angles )

    if ( EntityName == nil ) then return end

    if ( !EGSCanPlayerSpawnSENT( player, EntityName ) ) then return end

    if ( !gamemode.Call( "PlayerSpawnSENT", player, EntityName ) ) then return end

    local vStart = player:EyePos()
    local vForward = player:GetAimVector()

    if ( !tr ) then

        local trace = {}
        trace.start = vStart
        trace.endpos = vStart + ( vForward * 4096 )
        trace.filter = player

        tr = util.TraceLine( trace )

    end

    local entity = nil
    local PrintName = nil
    local sent = scripted_ents.GetStored( EntityName )

    if ( sent ) then

        local sent = sent.t

        ClassName = EntityName

            local SpawnFunction = scripted_ents.GetMember( EntityName, "SpawnFunction" )
            if ( !SpawnFunction ) then return end
            entity = SpawnFunction( sent, player, tr, EntityName )

            if ( IsValid( entity ) ) then
                entity:SetCreator( player )
            end

        ClassName = nil

        PrintName = sent.PrintName

    else

        local SpawnableEntities = list.Get( "SpawnableEntities" )
        if ( !SpawnableEntities ) then return end
        local EntTable = SpawnableEntities[ EntityName ]
        if ( !EntTable ) then return end

        PrintName = EntTable.PrintName

        local SpawnPos = tr.HitPos + tr.HitNormal * 16
        if ( EntTable.NormalOffset ) then SpawnPos = SpawnPos + tr.HitNormal * EntTable.NormalOffset end

        entity = ents.Create( EntTable.ClassName )
        entity:SetPos( SpawnPos )

        if ( EntTable.KeyValues ) then
            for k, v in pairs( EntTable.KeyValues ) do
                entity:SetKeyValue( k, v )
            end
        end

        if ( EntTable.Material ) then
            entity:SetMaterial( EntTable.Material )
        end

        entity:Spawn()
        entity:Activate()
        entity:SetAngles(Angles)

        if ( EntTable.DropToFloor ) then
            entity:DropToFloor()
        end

    end

    if ( IsValid( entity ) ) then

        if ( IsValid( player ) ) then
            gamemode.Call( "PlayerSpawnedSENT", player, entity )
        end

        player:AddCleanup( "sents", entity )
        entity:SetVar( "Player", player )

        return entity
    end

end

function TOOL:EGS_Spawn_ERP( player, command, arguments, trace, angle )

    -- ERP - Multipurpose spawn function.
    -- Effect / Ragdoll / Prop

    if ( arguments[ 1 ] == nil ) then return end
    if ( arguments[ 1 ]:find( "[./\\][/\\]" ) ) then return end
    if ( !gamemode.Call( "PlayerSpawnObject", player, arguments[ 1 ], arguments[ 2 ] ) ) then return end
    if ( !util.IsValidModel( arguments[ 1 ] ) ) then return end

    local iSkin = tonumber( arguments[ 2 ] ) or 0
    local strBody = arguments[ 3 ] or nil

    if ( util.IsValidProp( arguments[ 1 ] ) ) then

        return self:EGS_Spawn_Prop( player, arguments[ 1 ], iSkin, strBody, trace, angle )

    end

    if ( util.IsValidRagdoll( arguments[ 1 ] ) ) then

        return self:EGS_Spawn_Ragdoll( player, arguments[ 1 ], iSkin, strBody, trace, angle )

    end

    return self:EGS_Spawn_Effect( player, arguments[ 1 ], iSkin, strBody, trace, angle )

end

function TOOL:EGS_FixInvalidPhysicsObject( Prop )

    local PhysObj = Prop:GetPhysicsObject()
    if ( !IsValid( PhysObj ) ) then return end

    local min, max = PhysObj:GetAABB()
    if ( !min || !max ) then return end

    local PhysSize = (min - max):Length()
    if ( PhysSize > 5 ) then return end

    local min = Prop:OBBMins()
    local max = Prop:OBBMaxs()
    if ( !min || !max ) then return end

    local ModelSize = ( min - max ):Length()
    local Difference = math.abs( ModelSize - PhysSize )
    if ( Difference < 10 ) then return end

    Prop:PhysicsInitBox( min, max )
    Prop:SetCollisionGroup( COLLISION_GROUP_DEBRIS )

    local PhysObj = Prop:GetPhysicsObject()
    if ( !PhysObj ) then return end

    PhysObj:SetMass( 100 )
    PhysObj:Wake()

end

function TOOL:EGS_Spawn_Prop( player, model, iSkin, strBody, trace, angle )

    if ( !gamemode.Call( "PlayerSpawnProp", player, model ) ) then return end

    local e = self:EGS_DoPlayerEntitySpawn( player, "prop_physics", model, iSkin, strBody, trace, angle )

    if ( IsValid( player ) ) then
        gamemode.Call( "PlayerSpawnedProp", player, model, e )
    end

    self:EGS_FixInvalidPhysicsObject( e )

    DoPropSpawnedEffect( e )
    player:AddCleanup( "props", e )

    return e

end

function TOOL:EGS_Spawn_Effect( player, model, iSkin, strBody, trace, angle )

    if ( !gamemode.Call( "PlayerSpawnEffect", player, model ) ) then return end
    local e = self:EGS_DoPlayerEntitySpawn( player, "prop_effect", model, iSkin, strBody, trace, angle )
    if ( !IsValid( e ) ) then return end

    if ( IsValid( player ) ) then
        gamemode.Call( "PlayerSpawnedEffect", player, model, e )
    end

    DoPropSpawnedEffect( e )
    player:AddCleanup( "effects", e )

    return e

end

function TOOL:EGS_Spawn_Ragdoll( player, model, iSkin, strBody, trace, angle )

    if ( !gamemode.Call( "PlayerSpawnRagdoll", player, model ) ) then return end
    local e = self:EGS_DoPlayerEntitySpawn( player, "prop_ragdoll", model, iSkin, strBody, trace, angle )

    if ( IsValid( player ) ) then
        gamemode.Call( "PlayerSpawnedRagdoll", player, model, e )
    end

    DoPropSpawnedEffect( e )
    player:AddCleanup( "ragdolls", e )

    return e

end

function TOOL:EGS_DoPlayerEntitySpawn( player, entity_name, model, iSkin, strBody, trace, angle )

    local vStart = player:GetShootPos()
    local vForward = player:GetAimVector()

    local ent = ents.Create( entity_name )
    if ( !IsValid( ent ) ) then return end


    if ( entity_name == "prop_ragdoll" ) then
        angle.pitch = -90
    end

    ent:SetModel( model )
    ent:SetSkin( iSkin )
    ent:SetAngles( angle )
    if strBody then
        ent:SetBodyGroups( strBody )
    end
    ent:SetPos( trace.HitPos )
    ent:Spawn()
    ent:Activate()


    local vFlushPoint = trace.HitPos - ( trace.HitNormal * 512 )
    vFlushPoint = ent:NearestPoint( vFlushPoint )
    vFlushPoint = ent:GetPos() - vFlushPoint
    vFlushPoint = trace.HitPos + vFlushPoint

    if ( entity_name != "prop_ragdoll" ) then
        ent:SetPos( vFlushPoint )
        player:SendLua( "achievements.SpawnedProp()" )

    else

        local VecOffset = vFlushPoint - ent:GetPos()
        for i = 0, ent:GetPhysicsObjectCount() - 1 do
            local phys = ent:GetPhysicsObjectNum( i )
            phys:SetPos( phys:GetPos() + VecOffset )
        end

        player:SendLua( "achievements.SpawnedRagdoll()" )
    end

    return ent

end

if CLIENT then

    -- SilkIcons
    local egs_icon = "icon16/egs.png"
    local creator_icon = "icon16/wand.png"
    local delete_icon = "icon16/cross.png"
    local copy_icon = "icon16/page_copy.png"
    -- Prop Launcher compatability
    local pl_icon = "icon16/prop_launcher.png"

    -------------------------------------------
    -------------------------------------------
     --   Entity Context Menu MODIFICATIONS
    -------------------------------------------
    -------------------------------------------

    -- Add EGS option to entity context menu.
    properties.Add( "EGSSpawn", {
        MenuLabel = "Spawn using EGS",
        Order = 0,
        MenuIcon = egs_icon,

        Filter = function( self, ent, ply )
            if ( !IsValid( ent ) ) then return false end
            if ( ent:IsVehicle() ) then return false end
            if ( ent:IsPlayer() ) then return false end
            return true
        end,
        Action = function( self, ent )

            local entClass = ent:GetClass()
            local entName = entClass
            local entType = nil
            local entWep = nil

            if ent:IsWeapon() then
                entType = 3
            elseif ent:IsNPC() then
                entType = 2
                local gun = ent:GetActiveWeapon()
                if IsValid(gun) then
                    entWep = gun:GetClass()
                end
            else
                if entClass == "prop_physics"  or entClass == "prop_ragdoll" then
                    entName = ent:GetModel()
                    entType = 4
                else
                    entType = 0
                end
            end

            RunConsoleCommand( "gmod_tool", "egs" )

            if entName ~= nil then
                RunConsoleCommand( "egs_ent_name", entName )
            end
            if entType ~= nil then
                RunConsoleCommand( "egs_ent_type", entType )
            end
            if entWep ~= nil then
                RunConsoleCommand( "egs_ent_arg", entWep )
            end

        end,
        Receive = function( self, length, player )
            return
        end
    } )

    -- Add Creator option to entity context menu.
    properties.Add( "CreatorSpawn", {
        MenuLabel = "#spawnmenu.menu.spawn_with_toolgun",
        Order = 1,
        MenuIcon = creator_icon,

        Filter = function( self, ent, ply )
            if ( !IsValid( ent ) ) then return false end
            if ( ent:IsVehicle() ) then return false end
            if ( ent:IsPlayer() ) then return false end
            return true
        end,
        Action = function( self, ent )

            local entClass = ent:GetClass()
            local entName = entClass
            local entType = nil
            local entWep = nil

            if ent:IsWeapon() then
                entType = 3
            elseif ent:IsNPC() then
                entType = 2
                local gun = ent:GetActiveWeapon()
                if IsValid(gun) then
                    entWep = gun:GetClass()
                end
            else
                if entClass == "prop_physics"  or entClass == "prop_ragdoll" then
                    entName = ent:GetModel()
                    entType = 4
                else
                    entType = 0
                end
            end

            RunConsoleCommand( "gmod_tool", "creator" )

            if entName ~= nil then
                RunConsoleCommand( "creator_name", entName )
            end
            if entType ~= nil then
                RunConsoleCommand( "creator_type", entType )
            end
            if entWep ~= nil then
                RunConsoleCommand( "creator_arg", entWep )
            end

        end,
        Receive = function( self, length, player )
            return
        end
    } )

    -------------------------------------------
    -------------------------------------------
     --      Spawn Menu
    -------------------------------------------
    -------------------------------------------

    local valid_types = {
        ['entity'] = 0,
        ['vehicle'] = 1,
        ['npc'] = 2,
        ['weapon'] = 3,
        ['model'] = 4,
    }

    hook.Add('SpawnmenuIconMenuOpen', 'egs_spawnmenu_option', function(menu, icon, contentType)
        local type_id = valid_types[contentType]
        if not type_id then return end

        local spawn_name = type_id == 4 and icon.m_strModelName or icon.m_SpawnName

        menu:AddOption('Spawn Using EGS', function()
            RunConsoleCommand("gmod_tool", "egs") 
            RunConsoleCommand("egs_ent_type", type_id) 
            RunConsoleCommand("egs_ent_name", spawn_name) 
        end):SetImage(egs_icon)
    end)
end

-- Phew! That was a lot of code!
-- This is the EOF.
-- Pretty sure that means Eggs of Falcons.
-- Falcons are cool, but kiwis are better.
-- kbye.
-- ~Jax
--------------------------------------------------------------------------------------------------------------------
